"""
Arch Backend - Generate Arch Linux specific configurations

Converts Universal IR to:
- Package installation scripts (pacman + AUR)
- Systemd service units
- Installation guide
"""

import yaml
from pathlib import Path
from typing import Dict, List


class ArchBackend:
    def __init__(self, verbose: bool = False):
        self.verbose = verbose

    def log(self, message):
        if self.verbose:
            print(f"  [arch-backend] {message}")

    def generate(self, universal_path: Path, output_path: Path):
        """Generate Arch Linux configurations from Universal IR"""
        self.log(f"Generating Arch configs from: {universal_path}")

        # Create output directory structure
        output_path.mkdir(parents=True, exist_ok=True)
        (output_path / 'packages').mkdir(exist_ok=True)
        (output_path / 'systemd').mkdir(exist_ok=True)
        (output_path / 'systemd' / 'system').mkdir(exist_ok=True)

        # Load universal IR
        services = self._load_yaml(universal_path / 'services.yml')
        packages = self._load_yaml(universal_path / 'packages.yml')
        containers = self._load_yaml(universal_path / 'containers.yml')

        # Generate components
        self._generate_package_lists(packages, output_path)
        self._generate_install_script(output_path)
        self._generate_services_info(services, output_path)
        self._generate_readme(output_path, services, packages, containers)

        self.log(f"‚úÖ Arch configs generated at: {output_path}")

    def _load_yaml(self, file_path: Path) -> Dict:
        """Load a YAML file"""
        if not file_path.exists():
            return {}

        with open(file_path, 'r') as f:
            return yaml.safe_load(f)

    def _generate_package_lists(self, packages_data: Dict, output_path: Path):
        """Generate pacman.txt and aur.txt"""
        self.log("Generating package lists...")

        packages = packages_data.get('packages', {})
        system_packages = packages.get('system', [])
        home_packages = packages.get('home', [])

        all_packages = system_packages + home_packages

        # Separate into official and AUR packages
        official_packages = []
        aur_packages = []

        for pkg_info in all_packages:
            nixos_name = pkg_info.get('nixos_name', '')
            mappings = pkg_info.get('mappings', {})

            # Get Arch package name
            arch_name = mappings.get('arch', nixos_name)

            # Categorize as official or AUR (simplified heuristic)
            if self._is_aur_package(arch_name):
                aur_packages.append(arch_name)
            else:
                official_packages.append(arch_name)

        # Write pacman.txt
        pacman_file = output_path / 'packages' / 'pacman.txt'
        with open(pacman_file, 'w') as f:
            f.write("# Official Arch packages\n")
            f.write("# Install with: sudo pacman -S --needed $(cat pacman.txt | grep -v '^#')\n\n")
            for pkg in sorted(set(official_packages)):
                f.write(f"{pkg}\n")

        self.log(f"Created: {pacman_file} ({len(official_packages)} packages)")

        # Write aur.txt
        aur_file = output_path / 'packages' / 'aur.txt'
        with open(aur_file, 'w') as f:
            f.write("# AUR packages\n")
            f.write("# Install with: yay -S --needed $(cat aur.txt | grep -v '^#')\n\n")
            for pkg in sorted(set(aur_packages)):
                f.write(f"{pkg}\n")

        self.log(f"Created: {aur_file} ({len(aur_packages)} packages)")

    def _generate_install_script(self, output_path: Path):
        """Generate automated package installation script"""
        self.log("Generating install script...")

        script_content = """#!/bin/bash
# Arch Package Installation Script
# Auto-generated by nixos-translator

set -euo pipefail

echo "üöÄ Installing Arch packages..."

# Colors
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
NC='\\033[0m' # No Color

# Check if running as root
if [[ $EUID -eq 0 ]]; then
   echo -e "${RED}Don't run this script as root!${NC}"
   exit 1
fi

# Install official packages
if [ -f packages/pacman.txt ]; then
    echo -e "${GREEN}Installing official packages...${NC}"
    PACKAGES=$(grep -v '^#' packages/pacman.txt | grep -v '^$' | tr '\\n' ' ')

    if [ -n "$PACKAGES" ]; then
        sudo pacman -S --needed $PACKAGES
    fi
fi

# Install AUR helper if not present
if ! command -v yay &> /dev/null; then
    echo -e "${YELLOW}Installing yay AUR helper...${NC}"
    cd /tmp
    git clone https://aur.archlinux.org/yay.git
    cd yay
    makepkg -si --noconfirm
    cd ..
    rm -rf yay
fi

# Install AUR packages
if [ -f packages/aur.txt ]; then
    echo -e "${GREEN}Installing AUR packages...${NC}"
    AUR_PACKAGES=$(grep -v '^#' packages/aur.txt | grep -v '^$' | tr '\\n' ' ')

    if [ -n "$AUR_PACKAGES" ]; then
        yay -S --needed $AUR_PACKAGES
    fi
fi

echo -e "${GREEN}‚úÖ Package installation complete!${NC}"
echo ""
echo "Next steps:"
echo "1. Review systemd/ directory for service configurations"
echo "2. Set up containers using docker-compose"
echo "3. Configure secrets management"
"""

        script_file = output_path / 'packages' / 'install-packages.sh'
        with open(script_file, 'w') as f:
            f.write(script_content)

        # Make executable
        script_file.chmod(0o755)

        self.log(f"Created: {script_file}")

    def _generate_services_info(self, services_data: Dict, output_path: Path):
        """Generate service information and notes"""
        self.log("Generating services info...")

        services = services_data.get('services', {})

        info_content = "# Services Overview\n\n"
        info_content += "This file lists all services found in your NixOS configuration.\n\n"

        for category, service_list in services.items():
            if not service_list:
                continue

            info_content += f"## {category.upper()} Services\n\n"

            for service in service_list:
                name = service.get('name', 'unknown')
                svc_type = service.get('type', 'unknown')
                port = service.get('port', 'N/A')
                description = service.get('description', '')

                info_content += f"### {name}\n"
                info_content += f"- **Type**: {svc_type}\n"
                if port != 'N/A':
                    info_content += f"- **Port**: {port}\n"
                if description:
                    info_content += f"- **Description**: {description}\n"
                info_content += f"- **NixOS Path**: `{service.get('nixos_path', '')}`\n"

                # Add installation notes
                if svc_type == 'native':
                    info_content += f"\n**Installation on Arch:**\n"
                    info_content += f"```bash\n"

                    # Check if service is available in official repos
                    if name in ['jellyfin', 'couchdb']:
                        info_content += f"sudo pacman -S {name}\n"
                        info_content += f"sudo systemctl enable --now {name}\n"
                    else:
                        info_content += f"# Install {name} from AUR or manually\n"
                        info_content += f"yay -S {name}\n"

                    info_content += f"```\n"

                elif svc_type == 'container':
                    info_content += f"\n**Installation on Arch:**\n"
                    info_content += f"- Included in docker-compose configuration\n"
                    info_content += f"- See containers.yml for details\n"

                info_content += "\n"

        # Write to file
        services_file = output_path / 'SERVICES.md'
        with open(services_file, 'w') as f:
            f.write(info_content)

        self.log(f"Created: {services_file}")

    def _generate_readme(self, output_path: Path, services: Dict, packages: Dict, containers: Dict):
        """Generate main README for Arch configs"""
        self.log("Generating README...")

        total_services = sum(len(v) for v in services.get('services', {}).values())
        total_packages = len(packages.get('packages', {}).get('system', [])) + \
                        len(packages.get('packages', {}).get('home', []))
        total_containers = len(containers.get('containers', []))

        readme_content = f"""# Arch Linux Configuration
## Converted from NixOS

This directory contains Arch Linux equivalents of your NixOS configuration.

### üìä Statistics

- **Services**: {total_services}
- **Packages**: {total_packages}
- **Containers**: {total_containers}

### üìÅ Directory Structure

```
arch-hwc/
‚îú‚îÄ‚îÄ packages/
‚îÇ   ‚îú‚îÄ‚îÄ pacman.txt              # Official repo packages
‚îÇ   ‚îú‚îÄ‚îÄ aur.txt                 # AUR packages
‚îÇ   ‚îî‚îÄ‚îÄ install-packages.sh     # Automated installer
‚îú‚îÄ‚îÄ systemd/
‚îÇ   ‚îî‚îÄ‚îÄ system/                 # Service unit files
‚îú‚îÄ‚îÄ SERVICES.md                 # Service overview & installation guides
‚îî‚îÄ‚îÄ README.md                   # This file
```

### üöÄ Quick Start

1. **Install packages:**
   ```bash
   cd packages
   ./install-packages.sh
   ```

2. **Review services:**
   ```bash
   cat SERVICES.md
   ```

3. **Set up containers:**
   ```bash
   # Install Docker if not already installed
   sudo pacman -S docker docker-compose
   sudo systemctl enable --now docker
   sudo usermod -aG docker $USER

   # Deploy containers (see containers.yml from universal IR)
   ```

### üìù Manual Steps Required

This automated translation handles:
- ‚úÖ Package lists (system & user)
- ‚úÖ Service inventory
- ‚úÖ Container definitions

You'll need to manually configure:
- ‚ö†Ô∏è Secrets management (recommend: SOPS or Vault)
- ‚ö†Ô∏è Dotfiles (recommend: GNU Stow)
- ‚ö†Ô∏è System configuration (users, networking, firewall)
- ‚ö†Ô∏è Hardware-specific settings (GPU drivers, etc.)

### üîß Service Setup

See **SERVICES.md** for detailed installation instructions for each service.

**Native Services** (installed via pacman/AUR):
- Require systemd service units
- May need manual configuration

**Containerized Services**:
- Use Docker Compose
- Secrets need to be injected via environment files or Docker secrets

### üì¶ Package Categories

**Official Packages** (`pacman.txt`):
- Installed from official Arch repositories
- Install with: `sudo pacman -S --needed $(cat pacman.txt | grep -v '^#')`

**AUR Packages** (`aur.txt`):
- Installed from Arch User Repository
- Requires AUR helper (yay, paru)
- Install with: `yay -S --needed $(cat aur.txt | grep -v '^#')`

### üê≥ Container Management

Your containerized services can be managed with Docker Compose.
Reference the `containers.yml` from the universal IR to create compose files.

Example:
```bash
docker-compose -f compose/arr-stack/docker-compose.yml up -d
```

### üîê Secrets Management

**Recommended approach:**
1. Install SOPS: `yay -S sops`
2. Generate age key: `age-keygen -o ~/.config/sops/age/keys.txt`
3. Encrypt secrets: `sops secrets.yaml`
4. Reference in systemd units via `EnvironmentFile=`

### üìö Additional Resources

- [Arch Wiki](https://wiki.archlinux.org/)
- [Docker Documentation](https://docs.docker.com/)
- [SOPS Documentation](https://github.com/mozilla/sops)

### ‚ö†Ô∏è Important Notes

1. **GPU Drivers**: If you use NVIDIA GPU, install drivers manually:
   ```bash
   sudo pacman -S nvidia nvidia-utils
   ```

2. **Services**: Not all NixOS services have direct Arch equivalents.
   Check SERVICES.md for alternatives.

3. **Home Manager**: Your dotfiles need to be extracted separately.
   Consider using GNU Stow for dotfile management.

### üÜò Troubleshooting

**Package not found:**
- Check if package name differs in Arch
- Search AUR: `yay -Ss <package>`

**Service won't start:**
- Check logs: `journalctl -u <service> -f`
- Verify dependencies are installed
- Check configuration files

**Container issues:**
- Verify Docker is running: `systemctl status docker`
- Check logs: `docker-compose logs <service>`
- Ensure ports aren't in use: `ss -tlnp | grep <port>`

---

Generated by nixos-translator from your NixOS configuration.
"""

        readme_file = output_path / 'README.md'
        with open(readme_file, 'w') as f:
            f.write(readme_content)

        self.log(f"Created: {readme_file}")

    def _is_aur_package(self, package_name: str) -> bool:
        """Simple heuristic to determine if a package is likely in AUR"""
        # Known AUR packages
        aur_packages = [
            'ollama', 'immich', 'hyprland', 'protonvpn-cli',
            'obsidian', 'betterbird', 'onlyoffice-bin'
        ]

        # Packages ending with -bin, -git are usually AUR
        if package_name.endswith('-bin') or package_name.endswith('-git'):
            return True

        return package_name in aur_packages
